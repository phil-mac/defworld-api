{
  "version": 3,
  "sources": ["../../../services/socketService/index.ts"],
  "sourcesContent": ["import { Text } from '@codemirror/state';\nimport { nodeInit } from './node';\nimport { worldInit } from './world';\nimport { interpretGen } from '../interpreterService';\nconst { models } = require('../../schema');\nimport { addNewBlocksToBlocks, addNodeToBlocks } from \"../../utils/blockUtilFns\";\n\nexport const initSocketService = (io) => {\n  const nodes = {};\n  const worlds = {};\n\n  async function getNode (nodeId) {\n    if (!(nodeId in nodes)) {\n      // get content from database\n      const node = await models.node.findOne({ where: { id: nodeId } });\n\n      const content = node.toJSON().content;\n\n      console.log(\"got node content from db: \", content);\n\n      \n      nodes[nodeId] = { \n        updates: [], \n        pending: [],\n        doc: Text.of([content]),\n        users: {}\n      };\n    }\n    \n    return nodes[nodeId];\n  }\n\n  async function getWorld (worldId) {\n    if (!(worldId in worlds)) {\n      // const world = await models.world.findOne({ where: { id: worldId }});\n      // const grid = world.toJSON().grid; \n\n      const nodes = await models.node.findAll({ where: { worldId }, order: [['id', 'ASC']] });\n      const blocks = {};\n\n      for (let node of nodes) {\n        const { result: response } = await interpretGen(node.content);\n        const  { blocks: nodeBlocks } = response; // {x: number, y: number, z: number, color: string}[]\n        console.log('for node: ', node.id, ' got result: ', response)\n\n        // console.log({node})\n\n        // add node and nodeBlocks to Blocks object\n        addNodeToBlocks(blocks, node.id, node.pos);\n        console.log({blocks})\n        addNewBlocksToBlocks(blocks, node.id, node.pos, nodeBlocks)\n      }\n\n      \n      worlds[worldId] = {\n        users: {},\n        blocks // object, excludes empties, index explicit:  {2: [1,500], 4: [1,8]]\n        // grid, // array, includes empties, index implicit:   [[0,0],[0,0],[1,500],[0,0],[1,8],[0,0],[0,0],[0,0]]\n       }\n    }\n    return worlds[worldId];\n  }\n  \n  io.on('connection', socket => {\n    console.log('client connected to socket');\n\n    worldInit(io, socket, getWorld);\n    nodeInit(io, socket, getNode, getWorld);\n\n    socket.on('disconnect', () => {\n      console.log('client disconnected')\n    })\n  });\n};"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA,mBAAqB;AACrB,kBAAyB;AACzB,mBAA0B;AAC1B,gCAA6B;AAE7B,0BAAsD;AADtD,MAAM,EAAE,WAAW,QAAQ;AAGpB,MAAM,oBAAoB,CAAC,OAAO;AACvC,QAAM,QAAQ;AACd,QAAM,SAAS;AAEf,yBAAwB,QAAQ;AAC9B,QAAI,CAAE,WAAU,QAAQ;AAEtB,YAAM,OAAO,MAAM,OAAO,KAAK,QAAQ,EAAE,OAAO,EAAE,IAAI;AAEtD,YAAM,UAAU,KAAK,SAAS;AAE9B,cAAQ,IAAI,8BAA8B;AAG1C,YAAM,UAAU;AAAA,QACd,SAAS;AAAA,QACT,SAAS;AAAA,QACT,KAAK,kBAAK,GAAG,CAAC;AAAA,QACd,OAAO;AAAA;AAAA;AAIX,WAAO,MAAM;AAAA;AAGf,0BAAyB,SAAS;AAChC,QAAI,CAAE,YAAW,SAAS;AAIxB,YAAM,SAAQ,MAAM,OAAO,KAAK,QAAQ,EAAE,OAAO,EAAE,WAAW,OAAO,CAAC,CAAC,MAAM;AAC7E,YAAM,SAAS;AAEf,eAAS,QAAQ,QAAO;AACtB,cAAM,EAAE,QAAQ,aAAa,MAAM,4CAAa,KAAK;AACrD,cAAO,EAAE,QAAQ,eAAe;AAChC,gBAAQ,IAAI,cAAc,KAAK,IAAI,iBAAiB;AAKpD,iDAAgB,QAAQ,KAAK,IAAI,KAAK;AACtC,gBAAQ,IAAI,EAAC;AACb,sDAAqB,QAAQ,KAAK,IAAI,KAAK,KAAK;AAAA;AAIlD,aAAO,WAAW;AAAA,QAChB,OAAO;AAAA,QACP;AAAA;AAAA;AAIJ,WAAO,OAAO;AAAA;AAGhB,KAAG,GAAG,cAAc,YAAU;AAC5B,YAAQ,IAAI;AAEZ,gCAAU,IAAI,QAAQ;AACtB,8BAAS,IAAI,QAAQ,SAAS;AAE9B,WAAO,GAAG,cAAc,MAAM;AAC5B,cAAQ,IAAI;AAAA;AAAA;AAAA;",
  "names": []
}
