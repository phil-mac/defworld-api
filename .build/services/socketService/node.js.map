{
  "version": 3,
  "sources": ["../../../services/socketService/node.ts"],
  "sourcesContent": ["const { ChangeSet } = require('@codemirror/state');\nconst { Update } = require('@codemirror/collab'); \nconst { models } = require('../../schema');\nconst interpreterService = require('../interpreterService');\nconst { gridSideLength } = require('../../entities/world');\n\nfunction nodeInit(io, socket, getNode, getWorld) {\n  socket.on('joinNode', joinNode);\n\n  socket.on('leaveNode', async ({name, nodeId}) => {\n    console.log(name + ' left node ' + nodeId)\n    socket.leave(`node-${nodeId}`);\n    const node = await getNode(nodeId);\n    delete node.users[socket.id];\n    \n    node.pending = []; // TODO: remove this hack, find another to fix bug (like maybe just remove pending items for the user who left)\n    // socket.off('pullUpdates', pullUpdates);\n    // socket.off('pushUpdates', pushUpdates);\n    // socket.off('joinNode', joinNode);\n    socket.removeAllListeners('pullUpdates');\n    socket.removeAllListeners('pushUpdates');\n    // socket.removeAllListeners('leaveNode');\n    \n    socket.in(`node-${nodeId}`).emit('broadcast', name + 'left node ' + nodeId);\n  });\n\n  socket.on('disconnect', () => {\n    console.log('client disconnected from socket, for node stuff')\n    // probably not needed:\n    // socket.leave(`node-${nodeId}`);\n    // socket.off('pullUpdates', pullUpdates);\n    // socket.off('pushUpdates', pushUpdates);\n    // socket.off('joinNode', joinNode);\n  });\n\n  // ------- OT logic --------\n  \n  async function joinNode ({name, nodeId}) {\n    socket.join(`node-${nodeId}`);\n    const node = await getNode(nodeId);\n    const init = {\n      doc: node.doc.toString(), \n      rev: node.updates.length\n    }\n    socket.emit('initContent', init);\n    \n\n    console.log(name + ' joined node ' + nodeId)\n    node.users[socket.id] = {name};\n\n    socket.on('pullUpdates', pullUpdates);\n    \n    function pullUpdates({rev}) {\n      if (rev < node.updates.length){\n        resToPullUpdates(node.updates.slice(rev));\n      } else {\n        node.pending.push(resToPullUpdates)\n      }\n    }\n\n    function resToPullUpdates (updates) {\n      socket.emit('pullUpdatesRes', updates);\n    }\n\n    socket.on('pushUpdates', pushUpdates);\n\n    async function pushUpdates({rev, updates}) {\n      console.log('push updates')\n      const initialDoc = node.doc.toString();\n      \n      if (rev != node.updates.length) {\n        resToPushUpdates(false);\n        return;\n      }\n      \n      for (let update of updates) {\n        let changes = ChangeSet.fromJSON(update.changes);\n        let effects = JSON.parse(update.effects);\n        console.log(\"EFFECTS: \", effects);\n        node.updates.push({changes, effects: update.effects, clientId: update.clientID})\n        node.doc = changes.apply(node.doc);\n      }\n      \n      resToPushUpdates(true);\n      \n      while (node.pending.length){\n        node.pending.pop()!(updates);\n      }\n\n      const newDoc = node.doc.toString();\n\n      if (initialDoc === newDoc) return;\n      \n      let returnedNode = await models.node.update(\n        { content: newDoc },\n        { where: { id: nodeId }, returning: true, plain: true}\n      );\n      returnedNode = returnedNode[1].toJSON();\n\n      await updateWorldGrid({returnedNode, content: newDoc});\n    }\n\n    function resToPushUpdates(didSucceed) {\n      socket.emit('pushUpdatesRes', didSucceed);\n    }\n\n    async function updateWorldGrid({returnedNode, content}) {\n      \n      // await interpreting the code using node.doc.toString()\n      const { result } = await interpreterService.interpretGen(content);\n      \n      // get blocks out of the result \n      const evalResult = result.result;\n      const blocks = result.blocks; // [{x:1, y:1, z:1}, {x:2, y:2, z:2}]\n      // console.log(blocks)\n      // apply blocks to the grid\n      // const world = await models.world.findOne({ where: { id: returnedNode.worldId }});\n      const worldId = returnedNode.worldId;\n      const world = await getWorld(worldId);\n      // const grid = world.toJSON().grid; // [ [1,1], [2,2] ]\n      let grid = world.grid;\n\n      let blocksObj = {};\n      \n      blocks.forEach(block => {\n        const x = returnedNode.pos[0] + block.x;\n        const y = returnedNode.pos[1] + block.y;\n        const z = returnedNode.pos[2] + block.z;\n        const index = x + (gridSideLength * z) + (gridSideLength * gridSideLength * y);\n        blocksObj[index] = [returnedNode.id, 5];\n      });\n\n      // clear grid of old blocks from this node\n      grid.forEach((el, i) => {\n        if (el[0] === returnedNode.id && el[1] !== 50){\n          grid[i] = [0, 0];\n        }\n      })\n\n      grid.forEach((el, i) => {\n        let b = blocksObj[i];\n        if (!!b && grid[i][0] === 0 && grid[i][1] === 0){\n          grid[i] = b;\n        }\n      })\n\n      // save grid in server memory \n      world.grid = grid;\n      \n      // return {...returnedNode, result: result.result, blocks: JSON.stringify(result.blocks)};\n      \n      // socket send to clients:\n      // console.log({worldId, nodeId: returnedNode.id})\n          // new grid to clients\n      io.in(`world-${worldId}`).emit('gridUpdate', {grid});\n          // result of eval for this node\n      io.in(`node-${returnedNode.id}`).emit('evalResult', {result: evalResult})\n\n      // save grid to database, for now, later can just rederive from nodes\n      await models.world.update({grid}, {where: {id: returnedNode.worldId}});\n    }\n\n\n  }\n}\n\nmodule.exports = nodeInit;"],
  "mappings": "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",
  "names": []
}
