{
  "version": 3,
  "sources": ["../../../services/socketService/node.ts"],
  "sourcesContent": ["import { ChangeSet } from '@codemirror/state';\nconst { models } = require('../../schema');\nimport { interpretGen } from '../interpreterService';\nimport { addNewBlocksToBlocks, removeBlocksFromBlocks } from \"../../utils/blockUtilFns\";\n\nexport function nodeInit(io, socket, getNode, getWorld) {\n  socket.on('joinNode', joinNode);\n\n  socket.on('leaveNode', async ({name, nodeId}) => {\n    console.log(name + ' left node ' + nodeId)\n    socket.leave(`node-${nodeId}`);\n    const node = await getNode(nodeId);\n    delete node.users[socket.id];\n    \n    node.pending = []; // TODO: remove this hack - maybe just remove pending items for user who left\n   \n    socket.removeAllListeners('pullUpdates');\n    socket.removeAllListeners('pushUpdates');\n    \n    socket.in(`node-${nodeId}`).emit('broadcast', name + 'left node ' + nodeId);\n  });\n\n  async function joinNode ({name, nodeId}) {\n    socket.join(`node-${nodeId}`);\n    const node = await getNode(nodeId);\n    const init = {\n      doc: node.doc.toString(), \n      rev: node.updates.length\n    }\n    socket.emit('initContent', init);\n    console.log(name + ' joined node ' + nodeId)\n    node.users[socket.id] = {name};\n\n    socket.on('pullUpdates', pullUpdates);\n    \n    function pullUpdates({rev}) {\n      if (rev < node.updates.length){\n        resToPullUpdates(node.updates.slice(rev));\n      } else {\n        node.pending.push(resToPullUpdates)\n      }\n    }\n\n    function resToPullUpdates (updates) {\n      socket.emit('pullUpdatesRes', updates);\n    }\n\n    socket.on('pushUpdates', pushUpdates);\n\n    async function pushUpdates({rev, updates}) {\n      const initialDoc = node.doc.toString();\n      \n      if (rev != node.updates.length) {\n        resToPushUpdates(false);\n        return;\n      }\n      \n      for (let update of updates) {\n        let changes = ChangeSet.fromJSON(update.changes);\n        let effects = JSON.parse(update.effects);\n        node.updates.push({changes, effects: update.effects, clientId: update.clientID})\n        node.doc = changes.apply(node.doc);\n      }\n      \n      resToPushUpdates(true);\n      \n      while (node.pending.length){\n        node.pending.pop()!(updates);\n      }\n\n      const newDoc = node.doc.toString();\n\n      if (initialDoc === newDoc) return;\n      \n      let returnedNode = await models.node.update(\n        { content: newDoc },\n        { where: { id: nodeId }, returning: true, plain: true}\n      );\n      returnedNode = returnedNode[1].toJSON();\n\n      await updateWorldGrid({returnedNode, content: newDoc});\n    }\n\n    function resToPushUpdates(didSucceed) {\n      socket.emit('pushUpdatesRes', didSucceed);\n    }\n\n    async function updateWorldGrid({returnedNode, content}) {\n      const { result: response } = await interpretGen(content);\n      const {result: evalResult, error: evalError, blocks: newBlocks} = response;\n     \n      const worldId = returnedNode.worldId;\n      const world = await getWorld(worldId);\n      let blocks = world.blocks;\n\n      // let blocksObj = {};\n\n      removeBlocksFromBlocks(blocks, returnedNode.id);\n      const blocksToAdd = addNewBlocksToBlocks(blocks, returnedNode.id, returnedNode.pos, newBlocks);\n      \n      // blocks.forEach(block => {\n      //   const x = returnedNode.pos[0] + block.x;\n      //   const y = returnedNode.pos[1] + block.y;\n      //   const z = returnedNode.pos[2] + block.z;\n      //   const index = x + (gridSideLength * z) + (gridSideLength * gridSideLength * y);\n\n      //   const colorId = !!block.color ? colorToId(block.color) : -1;\n      //   console.log({block, colorId})\n      //   blocksObj[index] = [returnedNode.id, colorId];\n      // });\n\n      // clear grid of old blocks from this node\n      // grid.forEach((el, i) => {\n      //   if (el[0] === returnedNode.id && el[1] !== 500){\n      //     grid[i] = [0, 0];\n      //   }\n      // })\n\n      // grid.forEach((el, i) => {\n      //   let b = blocksObj[i];\n      //   if (!!b && grid[i][0] === 0 && grid[i][1] === 0){\n      //     grid[i] = b;\n      //   }\n      // })\n\n      // save grid in server memory \n      // world.grid = grid;\n      \n      // send new grid to all clients in world\n      io.in(`world-${worldId}`).emit('blocksUpdate', {blocksToAdd, nodeIdOfBlocksToRemove: returnedNode.id});\n      // send result of eval to clients in this node\n      io.in(`node-${returnedNode.id}`).emit('evalResult', {result: evalResult, error: evalError})\n\n      // TODO: for now, saving grid to database, later can just rederive from nodes on initial load\n      // await models.world.update({grid}, {where: {id: returnedNode.worldId}});\n    }\n\n\n  }\n}"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA,mBAA0B;AAE1B,gCAA6B;AAC7B,0BAA6D;AAF7D,MAAM,EAAE,WAAW,QAAQ;AAIpB,kBAAkB,IAAI,QAAQ,SAAS,UAAU;AACtD,SAAO,GAAG,YAAY;AAEtB,SAAO,GAAG,aAAa,OAAO,EAAC,MAAM,aAAY;AAC/C,YAAQ,IAAI,OAAO,gBAAgB;AACnC,WAAO,MAAM,QAAQ;AACrB,UAAM,OAAO,MAAM,QAAQ;AAC3B,WAAO,KAAK,MAAM,OAAO;AAEzB,SAAK,UAAU;AAEf,WAAO,mBAAmB;AAC1B,WAAO,mBAAmB;AAE1B,WAAO,GAAG,QAAQ,UAAU,KAAK,aAAa,OAAO,eAAe;AAAA;AAGtE,0BAAyB,EAAC,MAAM,UAAS;AACvC,WAAO,KAAK,QAAQ;AACpB,UAAM,OAAO,MAAM,QAAQ;AAC3B,UAAM,OAAO;AAAA,MACX,KAAK,KAAK,IAAI;AAAA,MACd,KAAK,KAAK,QAAQ;AAAA;AAEpB,WAAO,KAAK,eAAe;AAC3B,YAAQ,IAAI,OAAO,kBAAkB;AACrC,SAAK,MAAM,OAAO,MAAM,EAAC;AAEzB,WAAO,GAAG,eAAe;AAEzB,yBAAqB,EAAC,OAAM;AAC1B,UAAI,MAAM,KAAK,QAAQ,QAAO;AAC5B,yBAAiB,KAAK,QAAQ,MAAM;AAAA,aAC/B;AACL,aAAK,QAAQ,KAAK;AAAA;AAAA;AAItB,8BAA2B,SAAS;AAClC,aAAO,KAAK,kBAAkB;AAAA;AAGhC,WAAO,GAAG,eAAe;AAEzB,+BAA2B,EAAC,KAAK,WAAU;AACzC,YAAM,aAAa,KAAK,IAAI;AAE5B,UAAI,OAAO,KAAK,QAAQ,QAAQ;AAC9B,yBAAiB;AACjB;AAAA;AAGF,eAAS,UAAU,SAAS;AAC1B,YAAI,UAAU,uBAAU,SAAS,OAAO;AACxC,YAAI,UAAU,KAAK,MAAM,OAAO;AAChC,aAAK,QAAQ,KAAK,EAAC,SAAS,SAAS,OAAO,SAAS,UAAU,OAAO;AACtE,aAAK,MAAM,QAAQ,MAAM,KAAK;AAAA;AAGhC,uBAAiB;AAEjB,aAAO,KAAK,QAAQ,QAAO;AACzB,aAAK,QAAQ,MAAO;AAAA;AAGtB,YAAM,SAAS,KAAK,IAAI;AAExB,UAAI,eAAe;AAAQ;AAE3B,UAAI,eAAe,MAAM,OAAO,KAAK,OACnC,EAAE,SAAS,UACX,EAAE,OAAO,EAAE,IAAI,UAAU,WAAW,MAAM,OAAO;AAEnD,qBAAe,aAAa,GAAG;AAE/B,YAAM,gBAAgB,EAAC,cAAc,SAAS;AAAA;AAGhD,8BAA0B,YAAY;AACpC,aAAO,KAAK,kBAAkB;AAAA;AAGhC,mCAA+B,EAAC,cAAc,WAAU;AACtD,YAAM,EAAE,QAAQ,aAAa,MAAM,4CAAa;AAChD,YAAM,EAAC,QAAQ,YAAY,OAAO,WAAW,QAAQ,cAAa;AAElE,YAAM,UAAU,aAAa;AAC7B,YAAM,QAAQ,MAAM,SAAS;AAC7B,UAAI,SAAS,MAAM;AAInB,sDAAuB,QAAQ,aAAa;AAC5C,YAAM,cAAc,8CAAqB,QAAQ,aAAa,IAAI,aAAa,KAAK;AA+BpF,SAAG,GAAG,SAAS,WAAW,KAAK,gBAAgB,EAAC,aAAa,wBAAwB,aAAa;AAElG,SAAG,GAAG,QAAQ,aAAa,MAAM,KAAK,cAAc,EAAC,QAAQ,YAAY,OAAO;AAAA;AAAA;AAAA;",
  "names": []
}
