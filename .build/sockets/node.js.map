{
  "version": 3,
  "sources": ["../../sockets/node.ts"],
  "sourcesContent": ["import { ChangeSet } from '@codemirror/state';\nimport { models } from '../schema';\nimport { interpretGen } from '../services/interpreterService';\nimport { addNewBlocksToBlocks, removeBlocksFromBlocks } from \"../utils/blockUtils\";\nimport { Server, Socket } from 'socket.io';\n\nexport function nodeInit(\n  io: Server,\n  socket: Socket,\n  getNode: (nodeId: number) => any,\n  getWorld: (worldId: number) => any) {\n  socket.on('joinNode', joinNode);\n\n  socket.on('leaveNode', async ({ name, nodeId }: { name: string, nodeId: number }) => {\n    console.log(name + ' left node ' + nodeId)\n    socket.leave(`node-${nodeId}`);\n    const node = await getNode(nodeId);\n    delete node.users[socket.id];\n\n    node.pending = []; // TODO: remove this hack - maybe just remove pending items for user who left\n\n    socket.removeAllListeners('pullUpdates');\n    socket.removeAllListeners('pushUpdates');\n\n    socket.in(`node-${nodeId}`).emit('broadcast', name + 'left node ' + nodeId);\n  });\n\n  async function joinNode({ name, nodeId }: { name: string, nodeId: number }) {\n    socket.join(`node-${nodeId}`);\n    const node = await getNode(nodeId);\n    const init = {\n      doc: node.doc.toString(),\n      rev: node.updates.length\n    }\n    socket.emit('initContent', init);\n    console.log(name + ' joined node ' + nodeId)\n    node.users[socket.id] = { name };\n\n    socket.on('pullUpdates', pullUpdates);\n\n    function pullUpdates({ rev }: { rev: number }) {\n      if (rev < node.updates.length) {\n        resToPullUpdates(node.updates.slice(rev));\n      } else {\n        node.pending.push(resToPullUpdates)\n      }\n    }\n\n    function resToPullUpdates(updates: any) {\n      socket.emit('pullUpdatesRes', updates);\n    }\n\n    socket.on('pushUpdates', pushUpdates);\n\n    async function pushUpdates({ rev, updates }: {rev: number, updates: any}) {\n      const initialDoc = node.doc.toString();\n\n      if (rev != node.updates.length) {\n        resToPushUpdates(false);\n        return;\n      }\n\n      for (let update of updates) {\n        let changes = ChangeSet.fromJSON(update.changes);\n        // let effects = JSON.parse(update.effects);\n        node.updates.push({ changes, effects: update.effects, clientId: update.clientID })\n        node.doc = changes.apply(node.doc);\n      }\n\n      resToPushUpdates(true);\n\n      while (node.pending.length) {\n        node.pending.pop()!(updates);\n      }\n\n      const newDoc = node.doc.toString();\n\n      if (initialDoc === newDoc) return;\n\n      let returnedNode = await models.node.update(\n        { content: newDoc },\n        { where: { id: nodeId }, returning: true, plain: true }\n      );\n      returnedNode = returnedNode[1].toJSON();\n\n      await updateWorldGrid({ returnedNode, content: newDoc });\n    }\n\n    function resToPushUpdates(didSucceed: boolean) {\n      socket.emit('pushUpdatesRes', didSucceed);\n    }\n\n    async function updateWorldGrid({ returnedNode, content } : {returnedNode: any, content: string}) {\n      const { result: evalResult, error: evalError, blocks: newBlocks } = await interpretGen(content);\n\n      const worldId = returnedNode.worldId;\n      const world = await getWorld(worldId);\n      let blocks = world.blocks;\n\n      removeBlocksFromBlocks(blocks, returnedNode.id);\n      const blocksToAdd = addNewBlocksToBlocks(blocks, returnedNode.id, returnedNode.pos, newBlocks);\n\n      // send new grid to all clients in world\n      io.in(`world-${worldId}`).emit('blocksUpdate', { blocksToAdd, nodeIdOfBlocksToRemove: returnedNode.id });\n      \n      // send result of eval to clients in this node\n      io.in(`node-${returnedNode.id}`).emit('evalResult', { result: evalResult, error: evalError })\n    }\n  }\n}"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA,mBAA0B;AAC1B,oBAAuB;AACvB,gCAA6B;AAC7B,wBAA6D;AAGtD,kBACL,IACA,QACA,SACA,UAAoC;AACpC,SAAO,GAAG,YAAY;AAEtB,SAAO,GAAG,aAAa,OAAO,EAAE,MAAM,aAA+C;AACnF,YAAQ,IAAI,OAAO,gBAAgB;AACnC,WAAO,MAAM,QAAQ;AACrB,UAAM,OAAO,MAAM,QAAQ;AAC3B,WAAO,KAAK,MAAM,OAAO;AAEzB,SAAK,UAAU;AAEf,WAAO,mBAAmB;AAC1B,WAAO,mBAAmB;AAE1B,WAAO,GAAG,QAAQ,UAAU,KAAK,aAAa,OAAO,eAAe;AAAA;AAGtE,0BAAwB,EAAE,MAAM,UAA4C;AAC1E,WAAO,KAAK,QAAQ;AACpB,UAAM,OAAO,MAAM,QAAQ;AAC3B,UAAM,OAAO;AAAA,MACX,KAAK,KAAK,IAAI;AAAA,MACd,KAAK,KAAK,QAAQ;AAAA;AAEpB,WAAO,KAAK,eAAe;AAC3B,YAAQ,IAAI,OAAO,kBAAkB;AACrC,SAAK,MAAM,OAAO,MAAM,EAAE;AAE1B,WAAO,GAAG,eAAe;AAEzB,yBAAqB,EAAE,OAAwB;AAC7C,UAAI,MAAM,KAAK,QAAQ,QAAQ;AAC7B,yBAAiB,KAAK,QAAQ,MAAM;AAAA,aAC/B;AACL,aAAK,QAAQ,KAAK;AAAA;AAAA;AAItB,8BAA0B,SAAc;AACtC,aAAO,KAAK,kBAAkB;AAAA;AAGhC,WAAO,GAAG,eAAe;AAEzB,+BAA2B,EAAE,KAAK,WAAwC;AACxE,YAAM,aAAa,KAAK,IAAI;AAE5B,UAAI,OAAO,KAAK,QAAQ,QAAQ;AAC9B,yBAAiB;AACjB;AAAA;AAGF,eAAS,UAAU,SAAS;AAC1B,YAAI,UAAU,uBAAU,SAAS,OAAO;AAExC,aAAK,QAAQ,KAAK,EAAE,SAAS,SAAS,OAAO,SAAS,UAAU,OAAO;AACvE,aAAK,MAAM,QAAQ,MAAM,KAAK;AAAA;AAGhC,uBAAiB;AAEjB,aAAO,KAAK,QAAQ,QAAQ;AAC1B,aAAK,QAAQ,MAAO;AAAA;AAGtB,YAAM,SAAS,KAAK,IAAI;AAExB,UAAI,eAAe;AAAQ;AAE3B,UAAI,eAAe,MAAM,qBAAO,KAAK,OACnC,EAAE,SAAS,UACX,EAAE,OAAO,EAAE,IAAI,UAAU,WAAW,MAAM,OAAO;AAEnD,qBAAe,aAAa,GAAG;AAE/B,YAAM,gBAAgB,EAAE,cAAc,SAAS;AAAA;AAGjD,8BAA0B,YAAqB;AAC7C,aAAO,KAAK,kBAAkB;AAAA;AAGhC,mCAA+B,EAAE,cAAc,WAAkD;AAC/F,YAAM,EAAE,QAAQ,YAAY,OAAO,WAAW,QAAQ,cAAc,MAAM,4CAAa;AAEvF,YAAM,UAAU,aAAa;AAC7B,YAAM,QAAQ,MAAM,SAAS;AAC7B,UAAI,SAAS,MAAM;AAEnB,oDAAuB,QAAQ,aAAa;AAC5C,YAAM,cAAc,4CAAqB,QAAQ,aAAa,IAAI,aAAa,KAAK;AAGpF,SAAG,GAAG,SAAS,WAAW,KAAK,gBAAgB,EAAE,aAAa,wBAAwB,aAAa;AAGnG,SAAG,GAAG,QAAQ,aAAa,MAAM,KAAK,cAAc,EAAE,QAAQ,YAAY,OAAO;AAAA;AAAA;AAAA;",
  "names": []
}
